CCS PCH C Compiler, Version 4.084, 37642               28-Apr-09 01:41

               Filename: C:\Users\Bob\Desktop\KiiWiiCode\remote\remote.lst

               ROM used: 1624 bytes (5%)
                         Largest free fragment is 30308
               RAM used: 41 (3%) at main() level
                         45 (3%) worst case
               Stack:    2 worst case (1 in main + 1 for interrupts)

*
0000:  GOTO   018C
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF0.4
004E:  GOTO   0058
0052:  BTFSC  FF0.1
0054:  GOTO   009E
0058:  MOVFF  0F,00
005C:  MOVFF  10,01
0060:  MOVFF  11,02
0064:  MOVFF  12,03
0068:  MOVFF  13,04
006C:  MOVFF  0D,FE9
0070:  MOVFF  08,FEA
0074:  BSF    08.7
0076:  MOVFF  09,FE1
007A:  MOVFF  0A,FE2
007E:  MOVFF  0B,FD9
0082:  MOVFF  0C,FDA
0086:  MOVFF  14,FF3
008A:  MOVFF  15,FF4
008E:  MOVFF  16,FFA
0092:  MOVF   05,W
0094:  MOVFF  07,FE0
0098:  MOVFF  06,FD8
009C:  RETFIE 0
.................... #include <18f4520.h> 
.................... //////// Standard Header file for the PIC18F4520 device //////////////// 
.................... #device PIC18F4520 
.................... #list 
....................  
.................... #device ICD=TRUE 
.................... #fuses HS,NOLVP,NOWDT 
.................... #use delay(clock=20000000) 
*
0164:  CLRF   FEA
0166:  MOVLW  25
0168:  MOVWF  FE9
016A:  MOVF   FEF,W
016C:  BZ    0188
016E:  MOVLW  06
0170:  MOVWF  01
0172:  CLRF   00
0174:  DECFSZ 00,F
0176:  BRA    0174
0178:  DECFSZ 01,F
017A:  BRA    0172
017C:  MOVLW  7B
017E:  MOVWF  00
0180:  DECFSZ 00,F
0182:  BRA    0180
0184:  DECFSZ FEF,F
0186:  BRA    016E
0188:  GOTO   0658 (RETURN)
.................... #use rs232 (baud=9600, STREAM=TERM, xmit=PIN_C6, rcv=PIN_C7) 
*
011C:  BTFSS  F9E.4
011E:  BRA    011C
0120:  MOVWF  FAD
0122:  RETLW  00
.................... #use rs232 (baud=9600, STREAM=XBEE, xmit=PIN_B3, rcv=PIN_B2,ERRORS,FORCE_SW,parity=N,bits=8) //A1 goes to TX0, A2 goes to RX1 
0124:  BCF    F93.3
0126:  BCF    F8A.3
0128:  MOVLW  08
012A:  MOVWF  01
012C:  BRA    012E
012E:  NOP   
0130:  BSF    01.7
0132:  BRA    0150
0134:  BCF    01.7
0136:  RRCF   25,F
0138:  BTFSC  FD8.0
013A:  BSF    F8A.3
013C:  BTFSS  FD8.0
013E:  BCF    F8A.3
0140:  BSF    01.6
0142:  BRA    0150
0144:  BCF    01.6
0146:  DECFSZ 01,F
0148:  BRA    0136
014A:  BRA    014C
014C:  NOP   
014E:  BSF    F8A.3
0150:  MOVLW  A7
0152:  MOVWF  FE9
0154:  DECFSZ FE9,F
0156:  BRA    0154
0158:  BRA    015A
015A:  BTFSC  01.7
015C:  BRA    0134
015E:  BTFSC  01.6
0160:  BRA    0144
0162:  RETLW  00
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <input.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1() { 
....................    char digit; 
....................  
....................    digit = getc(); 
....................  
....................    putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1(); 
....................    lo = gethex1(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           putc(c); 
....................           putc(' '); 
....................           putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
.................... #if !defined(__PCD__) 
.................... signed int8 get_int() { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   get_string(s, 5); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... signed int16 get_int() { 
....................   char s[5]; 
....................   signed int16 i; 
....................  
....................   get_string(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... signed int16 get_long() { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   get_string(s, 7); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... signed int32 get_long() { 
....................   char s[7]; 
....................   signed int32 l; 
....................  
....................   get_string(s, 10); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... float get_float() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define GREEN_LED       PIN_A5      // define the pins 
.................... #define YELLOW_LED      PIN_B4 
.................... #define RED_LED         PIN_B5 
.................... #define PUSH_BUTTON     PIN_A4 
.................... #define BUTTON1         PIN_D2 
.................... #define BUTTON2         PIN_D4 
.................... #define BUTTON3         PIN_D6 
.................... #define VOLUME          0x01        // button values 
.................... #define PITCH           0x02 
.................... #define WAH             0x03 
.................... #define ARP             0x04 
.................... #define HAR             0x05 
.................... #define PUL             0x06 
.................... #define XMIN         46          // raw adc offsets (min adc) 
.................... #define YMIN         54 
.................... #define ZMIN         55 
.................... #define XMAX            147         // total adc ranges (max adc) 
.................... #define YMAX            153 
.................... #define ZMAX            153 
....................  
.................... #INT_EXT2 
.................... void wegetsignal() {                // toggle red when remote receives data (no application) 
....................  ext_int_edge( 2, H_TO_L); 
*
009E:  BCF    FF1.4
.................... } 
....................  
00A0:  BCF    FF0.1
00A2:  GOTO   0058
.................... char min(char a, char b) { 
....................    if (a < b) return a; 
*
0106:  MOVF   2A,W
0108:  SUBWF  29,W
010A:  BC    0114
010C:  MOVFF  29,01
0110:  BRA    011A
....................    else return b; 
0112:  BRA    011A
0114:  MOVFF  2A,01
0118:  BRA    011A
.................... } 
011A:  RETLW  00
....................  
.................... void main() { 
*
018C:  CLRF   FF8
018E:  BCF    FD0.7
0190:  BSF    08.7
0192:  CLRF   FEA
0194:  CLRF   FE9
0196:  BSF    FB8.3
0198:  MOVLW  08
019A:  MOVWF  FAF
019C:  MOVLW  02
019E:  MOVWF  FB0
01A0:  MOVLW  A6
01A2:  MOVWF  FAC
01A4:  MOVLW  90
01A6:  MOVWF  FAB
01A8:  BCF    F93.3
01AA:  BSF    F8A.3
01AC:  MOVF   FC1,W
01AE:  ANDLW  C0
01B0:  IORLW  0F
01B2:  MOVWF  FC1
01B4:  MOVLW  07
01B6:  MOVWF  FB4
01B8:  CLRF   18
01BA:  CLRF   19
....................     char ADC_1, ADC_2, ADC_3, i; 
....................     long buffer; 
....................     unsigned char arpOn = 0; 
01BC:  CLRF   24
....................     enable_interrupts(INT_EXT2); 
01BE:  BSF    FF0.4
....................     enable_interrupts(global); 
01C0:  MOVLW  C0
01C2:  IORWF  FF2,F
....................  
....................     setup_timer_0(RTCC_INTERNAL); 
01C4:  MOVLW  80
01C6:  MOVWF  FD5
....................     setup_adc_ports (AN0_TO_AN3_ANALOG); 
01C8:  MOVF   FC1,W
01CA:  ANDLW  C0
01CC:  IORLW  0B
01CE:  MOVWF  FC1
....................     setup_adc(ADC_CLOCK_INTERNAL); 
01D0:  MOVF   FC0,W
01D2:  ANDLW  C0
01D4:  IORLW  07
01D6:  MOVWF  FC0
01D8:  BCF    FC0.7
01DA:  BSF    FC2.0
....................  
....................     while(TRUE){ 
....................         if (input(BUTTON1) == 1 && input(BUTTON2) == 0 && input(BUTTON3) == 0) { // volume button pushed 
01DC:  BSF    F95.2
01DE:  BTFSS  F83.2
01E0:  BRA    0290
01E2:  BSF    F95.4
01E4:  BTFSC  F83.4
01E6:  BRA    0290
01E8:  BSF    F95.6
01EA:  BTFSC  F83.6
01EC:  BRA    0290
....................             set_adc_channel(1);              // y axis 
01EE:  MOVLW  04
01F0:  MOVWF  01
01F2:  MOVF   FC2,W
01F4:  ANDLW  C3
01F6:  IORWF  01,W
01F8:  MOVWF  FC2
....................             for (i = 0; i < 8; i++) {        // average 8 samples 
01FA:  CLRF   21
01FC:  MOVF   21,W
01FE:  SUBLW  07
0200:  BNC   0214
....................                 buffer += read_adc(); 
0202:  BSF    FC2.1
0204:  BTFSC  FC2.1
0206:  BRA    0204
0208:  MOVF   FC4,W
020A:  ADDWF  22,F
020C:  MOVLW  00
020E:  ADDWFC 23,F
....................             } 
0210:  INCF   21,F
0212:  BRA    01FC
....................             buffer = buffer >> 3; 
0214:  RRCF   23,F
0216:  RRCF   22,F
0218:  RRCF   23,F
021A:  RRCF   22,F
021C:  RRCF   23,F
021E:  RRCF   22,F
0220:  MOVLW  1F
0222:  ANDWF  23,F
....................             ADC_1 = min((((long)buffer - YMIN) * 127) / (YMAX - YMIN), 127) & 0xFF; 
0224:  MOVLW  36
0226:  SUBWF  22,W
0228:  MOVWF  25
022A:  MOVLW  00
022C:  SUBWFB 23,W
022E:  MOVWF  26
0230:  MOVWF  28
0232:  MOVFF  25,27
0236:  CLRF   2A
0238:  MOVLW  7F
023A:  MOVWF  29
023C:  RCALL  00A6
023E:  MOVFF  02,27
0242:  MOVFF  01,26
0246:  MOVFF  02,29
024A:  MOVFF  01,28
024E:  CLRF   2B
0250:  MOVLW  63
0252:  MOVWF  2A
0254:  RCALL  00C4
0256:  MOVFF  02,28
025A:  MOVFF  01,27
025E:  MOVFF  01,29
0262:  MOVLW  7F
0264:  MOVWF  2A
0266:  RCALL  0106
0268:  MOVFF  01,1E
....................             delay_us(25); 
026C:  MOVLW  29
026E:  MOVWF  00
0270:  DECFSZ 00,F
0272:  BRA    0270
0274:  NOP   
....................              
....................             output_low(RED_LED); 
0276:  BCF    F93.5
0278:  BCF    F8A.5
....................              
....................             fputc(VOLUME,TERM); 
027A:  MOVLW  01
027C:  RCALL  011C
....................             fputc(ADC_1,TERM); 
027E:  MOVF   1E,W
0280:  RCALL  011C
....................              
....................             fputc(VOLUME,XBEE); 
0282:  MOVLW  01
0284:  MOVWF  25
0286:  RCALL  0124
....................             fputc(ADC_1,XBEE); 
0288:  MOVFF  1E,25
028C:  RCALL  0124
....................         } 
....................         else if (input(BUTTON1) == 0 && input(BUTTON2) == 1 && input(BUTTON3) == 0) { // pitch button pushed 
028E:  BRA    0626
0290:  BSF    F95.2
0292:  BTFSC  F83.2
0294:  BRA    0344
0296:  BSF    F95.4
0298:  BTFSS  F83.4
029A:  BRA    0344
029C:  BSF    F95.6
029E:  BTFSC  F83.6
02A0:  BRA    0344
....................             set_adc_channel(2);              // z axis 
02A2:  MOVLW  08
02A4:  MOVWF  01
02A6:  MOVF   FC2,W
02A8:  ANDLW  C3
02AA:  IORWF  01,W
02AC:  MOVWF  FC2
....................             for (i = 0; i < 8; i++) {        // average 8 samples 
02AE:  CLRF   21
02B0:  MOVF   21,W
02B2:  SUBLW  07
02B4:  BNC   02C8
....................                 buffer += read_adc(); 
02B6:  BSF    FC2.1
02B8:  BTFSC  FC2.1
02BA:  BRA    02B8
02BC:  MOVF   FC4,W
02BE:  ADDWF  22,F
02C0:  MOVLW  00
02C2:  ADDWFC 23,F
....................             } 
02C4:  INCF   21,F
02C6:  BRA    02B0
....................             buffer = buffer >> 3; 
02C8:  RRCF   23,F
02CA:  RRCF   22,F
02CC:  RRCF   23,F
02CE:  RRCF   22,F
02D0:  RRCF   23,F
02D2:  RRCF   22,F
02D4:  MOVLW  1F
02D6:  ANDWF  23,F
....................             ADC_2 = min((((long)buffer - ZMIN) * 127) / (ZMAX - ZMIN), 127) & 0xFF; 
02D8:  MOVLW  37
02DA:  SUBWF  22,W
02DC:  MOVWF  25
02DE:  MOVLW  00
02E0:  SUBWFB 23,W
02E2:  MOVWF  26
02E4:  MOVWF  28
02E6:  MOVFF  25,27
02EA:  CLRF   2A
02EC:  MOVLW  7F
02EE:  MOVWF  29
02F0:  RCALL  00A6
02F2:  MOVFF  02,27
02F6:  MOVFF  01,26
02FA:  MOVFF  02,29
02FE:  MOVFF  01,28
0302:  CLRF   2B
0304:  MOVLW  62
0306:  MOVWF  2A
0308:  RCALL  00C4
030A:  MOVFF  02,28
030E:  MOVFF  01,27
0312:  MOVFF  01,29
0316:  MOVLW  7F
0318:  MOVWF  2A
031A:  RCALL  0106
031C:  MOVFF  01,1F
....................             delay_us(25); 
0320:  MOVLW  29
0322:  MOVWF  00
0324:  DECFSZ 00,F
0326:  BRA    0324
0328:  NOP   
....................              
....................             output_low(YELLOW_LED); 
032A:  BCF    F93.4
032C:  BCF    F8A.4
....................              
....................             fputc(PITCH,TERM); 
032E:  MOVLW  02
0330:  RCALL  011C
....................             fputc(ADC_2,TERM); 
0332:  MOVF   1F,W
0334:  RCALL  011C
....................              
....................             fputc(PITCH,XBEE); 
0336:  MOVLW  02
0338:  MOVWF  25
033A:  RCALL  0124
....................             fputc(ADC_2,XBEE); 
033C:  MOVFF  1F,25
0340:  RCALL  0124
....................         } 
....................         else if (input(BUTTON1) == 0 && input(BUTTON2) == 0 && input(BUTTON3) == 1) { // wah button pushed 
0342:  BRA    0626
0344:  BSF    F95.2
0346:  BTFSC  F83.2
0348:  BRA    03F8
034A:  BSF    F95.4
034C:  BTFSC  F83.4
034E:  BRA    03F8
0350:  BSF    F95.6
0352:  BTFSS  F83.6
0354:  BRA    03F8
....................             set_adc_channel(3);              // x axis 
0356:  MOVLW  0C
0358:  MOVWF  01
035A:  MOVF   FC2,W
035C:  ANDLW  C3
035E:  IORWF  01,W
0360:  MOVWF  FC2
....................             for (i = 0; i < 8; i++) {        // average 8 samples 
0362:  CLRF   21
0364:  MOVF   21,W
0366:  SUBLW  07
0368:  BNC   037C
....................                 buffer += read_adc(); 
036A:  BSF    FC2.1
036C:  BTFSC  FC2.1
036E:  BRA    036C
0370:  MOVF   FC4,W
0372:  ADDWF  22,F
0374:  MOVLW  00
0376:  ADDWFC 23,F
....................             } 
0378:  INCF   21,F
037A:  BRA    0364
....................             buffer = buffer >> 3; 
037C:  RRCF   23,F
037E:  RRCF   22,F
0380:  RRCF   23,F
0382:  RRCF   22,F
0384:  RRCF   23,F
0386:  RRCF   22,F
0388:  MOVLW  1F
038A:  ANDWF  23,F
....................             ADC_3 = min((((long)buffer - XMIN) * 127) / (XMAX - XMIN), 127) & 0xFF; 
038C:  MOVLW  2E
038E:  SUBWF  22,W
0390:  MOVWF  25
0392:  MOVLW  00
0394:  SUBWFB 23,W
0396:  MOVWF  26
0398:  MOVWF  28
039A:  MOVFF  25,27
039E:  CLRF   2A
03A0:  MOVLW  7F
03A2:  MOVWF  29
03A4:  RCALL  00A6
03A6:  MOVFF  02,27
03AA:  MOVFF  01,26
03AE:  MOVFF  02,29
03B2:  MOVFF  01,28
03B6:  CLRF   2B
03B8:  MOVLW  65
03BA:  MOVWF  2A
03BC:  RCALL  00C4
03BE:  MOVFF  02,28
03C2:  MOVFF  01,27
03C6:  MOVFF  01,29
03CA:  MOVLW  7F
03CC:  MOVWF  2A
03CE:  RCALL  0106
03D0:  MOVFF  01,20
....................             delay_us(25); 
03D4:  MOVLW  29
03D6:  MOVWF  00
03D8:  DECFSZ 00,F
03DA:  BRA    03D8
03DC:  NOP   
....................              
....................             output_low(GREEN_LED); 
03DE:  BCF    F92.5
03E0:  BCF    F89.5
....................              
....................             fputc(WAH,TERM); 
03E2:  MOVLW  03
03E4:  RCALL  011C
....................             fputc(ADC_3,TERM); 
03E6:  MOVF   20,W
03E8:  RCALL  011C
....................              
....................             fputc(WAH,XBEE); 
03EA:  MOVLW  03
03EC:  MOVWF  25
03EE:  RCALL  0124
....................             fputc(ADC_3,XBEE); 
03F0:  MOVFF  20,25
03F4:  RCALL  0124
....................         } 
....................         else if (input(BUTTON1) == 1 && input(BUTTON2) == 1 && input(BUTTON3) == 0) { // random arpeggiator button pushed 
03F6:  BRA    0626
03F8:  BSF    F95.2
03FA:  BTFSS  F83.2
03FC:  BRA    04B8
03FE:  BSF    F95.4
0400:  BTFSS  F83.4
0402:  BRA    04B8
0404:  BSF    F95.6
0406:  BTFSC  F83.6
0408:  BRA    04B8
....................             if (arpOn == 0) { 
040A:  MOVF   24,F
040C:  BNZ   041C
....................                  arpOn = 1; 
040E:  MOVLW  01
0410:  MOVWF  24
....................                  fputc(0x09,TERM); 
0412:  MOVLW  09
0414:  RCALL  011C
....................                  
....................                  fputc(0x09,XBEE); 
0416:  MOVLW  09
0418:  MOVWF  25
041A:  RCALL  0124
....................             } 
....................             set_adc_channel(3);              // x axis 
041C:  MOVLW  0C
041E:  MOVWF  01
0420:  MOVF   FC2,W
0422:  ANDLW  C3
0424:  IORWF  01,W
0426:  MOVWF  FC2
....................             for (i = 0; i < 8; i++) { 
0428:  CLRF   21
042A:  MOVF   21,W
042C:  SUBLW  07
042E:  BNC   0442
....................                 buffer += read_adc(); 
0430:  BSF    FC2.1
0432:  BTFSC  FC2.1
0434:  BRA    0432
0436:  MOVF   FC4,W
0438:  ADDWF  22,F
043A:  MOVLW  00
043C:  ADDWFC 23,F
....................             } 
043E:  INCF   21,F
0440:  BRA    042A
....................             buffer = buffer >> 3; 
0442:  RRCF   23,F
0444:  RRCF   22,F
0446:  RRCF   23,F
0448:  RRCF   22,F
044A:  RRCF   23,F
044C:  RRCF   22,F
044E:  MOVLW  1F
0450:  ANDWF  23,F
....................             ADC_3 = min((((long)buffer - XMIN) * 127) / (XMAX - XMIN), 127) & 0xFF; 
0452:  MOVLW  2E
0454:  SUBWF  22,W
0456:  MOVWF  25
0458:  MOVLW  00
045A:  SUBWFB 23,W
045C:  MOVWF  26
045E:  MOVWF  28
0460:  MOVFF  25,27
0464:  CLRF   2A
0466:  MOVLW  7F
0468:  MOVWF  29
046A:  RCALL  00A6
046C:  MOVFF  02,27
0470:  MOVFF  01,26
0474:  MOVFF  02,29
0478:  MOVFF  01,28
047C:  CLRF   2B
047E:  MOVLW  65
0480:  MOVWF  2A
0482:  RCALL  00C4
0484:  MOVFF  02,28
0488:  MOVFF  01,27
048C:  MOVFF  01,29
0490:  MOVLW  7F
0492:  MOVWF  2A
0494:  RCALL  0106
0496:  MOVFF  01,20
....................              
....................             output_low(RED_LED); 
049A:  BCF    F93.5
049C:  BCF    F8A.5
....................             output_low(YELLOW_LED); 
049E:  BCF    F93.4
04A0:  BCF    F8A.4
....................              
....................             fputc(ARP,TERM); 
04A2:  MOVLW  04
04A4:  RCALL  011C
....................             fputc(ADC_3,TERM); 
04A6:  MOVF   20,W
04A8:  RCALL  011C
....................              
....................             fputc(ARP,XBEE); 
04AA:  MOVLW  04
04AC:  MOVWF  25
04AE:  RCALL  0124
....................             fputc(ADC_3,XBEE); 
04B0:  MOVFF  20,25
04B4:  RCALL  0124
....................         } 
....................         else if (input(BUTTON1) == 0 && input(BUTTON2) == 1 && input(BUTTON3) == 1) { // harmonizer button pushed 
04B6:  BRA    0626
04B8:  BSF    F95.2
04BA:  BTFSC  F83.2
04BC:  BRA    0570
04BE:  BSF    F95.4
04C0:  BTFSS  F83.4
04C2:  BRA    0570
04C4:  BSF    F95.6
04C6:  BTFSS  F83.6
04C8:  BRA    0570
....................             set_adc_channel(3);              // x axis 
04CA:  MOVLW  0C
04CC:  MOVWF  01
04CE:  MOVF   FC2,W
04D0:  ANDLW  C3
04D2:  IORWF  01,W
04D4:  MOVWF  FC2
....................             for (i = 0; i < 8; i++) {        // average 8 samples 
04D6:  CLRF   21
04D8:  MOVF   21,W
04DA:  SUBLW  07
04DC:  BNC   04F0
....................                 buffer += read_adc(); 
04DE:  BSF    FC2.1
04E0:  BTFSC  FC2.1
04E2:  BRA    04E0
04E4:  MOVF   FC4,W
04E6:  ADDWF  22,F
04E8:  MOVLW  00
04EA:  ADDWFC 23,F
....................             } 
04EC:  INCF   21,F
04EE:  BRA    04D8
....................             buffer = buffer >> 3; 
04F0:  RRCF   23,F
04F2:  RRCF   22,F
04F4:  RRCF   23,F
04F6:  RRCF   22,F
04F8:  RRCF   23,F
04FA:  RRCF   22,F
04FC:  MOVLW  1F
04FE:  ANDWF  23,F
....................             ADC_3 = min((((long)buffer - XMIN) * 127) / (XMAX - XMIN), 127) & 0xFF; 
0500:  MOVLW  2E
0502:  SUBWF  22,W
0504:  MOVWF  25
0506:  MOVLW  00
0508:  SUBWFB 23,W
050A:  MOVWF  26
050C:  MOVWF  28
050E:  MOVFF  25,27
0512:  CLRF   2A
0514:  MOVLW  7F
0516:  MOVWF  29
0518:  RCALL  00A6
051A:  MOVFF  02,27
051E:  MOVFF  01,26
0522:  MOVFF  02,29
0526:  MOVFF  01,28
052A:  CLRF   2B
052C:  MOVLW  65
052E:  MOVWF  2A
0530:  RCALL  00C4
0532:  MOVFF  02,28
0536:  MOVFF  01,27
053A:  MOVFF  01,29
053E:  MOVLW  7F
0540:  MOVWF  2A
0542:  RCALL  0106
0544:  MOVFF  01,20
....................             delay_us(25); 
0548:  MOVLW  29
054A:  MOVWF  00
054C:  DECFSZ 00,F
054E:  BRA    054C
0550:  NOP   
....................              
....................             output_low(YELLOW_LED); 
0552:  BCF    F93.4
0554:  BCF    F8A.4
....................             output_low(GREEN_LED); 
0556:  BCF    F92.5
0558:  BCF    F89.5
....................              
....................             fputc(HAR,TERM); 
055A:  MOVLW  05
055C:  RCALL  011C
....................             fputc(ADC_3,TERM); 
055E:  MOVF   20,W
0560:  RCALL  011C
....................              
....................             fputc(HAR,XBEE); 
0562:  MOVLW  05
0564:  MOVWF  25
0566:  RCALL  0124
....................             fputc(ADC_3,XBEE); 
0568:  MOVFF  20,25
056C:  RCALL  0124
....................         } 
....................         else if (input(BUTTON1) == 1 && input(BUTTON2) == 0 && input(BUTTON3) == 1) { // pulser button pushed 
056E:  BRA    0626
0570:  BSF    F95.2
0572:  BTFSS  F83.2
0574:  BRA    0626
0576:  BSF    F95.4
0578:  BTFSC  F83.4
057A:  BRA    0626
057C:  BSF    F95.6
057E:  BTFSS  F83.6
0580:  BRA    0626
....................             set_adc_channel(3);              // x axis 
0582:  MOVLW  0C
0584:  MOVWF  01
0586:  MOVF   FC2,W
0588:  ANDLW  C3
058A:  IORWF  01,W
058C:  MOVWF  FC2
....................             for (i = 0; i < 8; i++) {        // average 8 samples 
058E:  CLRF   21
0590:  MOVF   21,W
0592:  SUBLW  07
0594:  BNC   05A8
....................                 buffer += read_adc(); 
0596:  BSF    FC2.1
0598:  BTFSC  FC2.1
059A:  BRA    0598
059C:  MOVF   FC4,W
059E:  ADDWF  22,F
05A0:  MOVLW  00
05A2:  ADDWFC 23,F
....................             } 
05A4:  INCF   21,F
05A6:  BRA    0590
....................             buffer = buffer >> 3; 
05A8:  RRCF   23,F
05AA:  RRCF   22,F
05AC:  RRCF   23,F
05AE:  RRCF   22,F
05B0:  RRCF   23,F
05B2:  RRCF   22,F
05B4:  MOVLW  1F
05B6:  ANDWF  23,F
....................             ADC_3 = min((((long)buffer - XMIN) * 127) / (XMAX - XMIN), 127) & 0xFF; 
05B8:  MOVLW  2E
05BA:  SUBWF  22,W
05BC:  MOVWF  25
05BE:  MOVLW  00
05C0:  SUBWFB 23,W
05C2:  MOVWF  26
05C4:  MOVWF  28
05C6:  MOVFF  25,27
05CA:  CLRF   2A
05CC:  MOVLW  7F
05CE:  MOVWF  29
05D0:  RCALL  00A6
05D2:  MOVFF  02,27
05D6:  MOVFF  01,26
05DA:  MOVFF  02,29
05DE:  MOVFF  01,28
05E2:  CLRF   2B
05E4:  MOVLW  65
05E6:  MOVWF  2A
05E8:  RCALL  00C4
05EA:  MOVFF  02,28
05EE:  MOVFF  01,27
05F2:  MOVFF  01,29
05F6:  MOVLW  7F
05F8:  MOVWF  2A
05FA:  RCALL  0106
05FC:  MOVFF  01,20
....................             delay_us(25); 
0600:  MOVLW  29
0602:  MOVWF  00
0604:  DECFSZ 00,F
0606:  BRA    0604
0608:  NOP   
....................              
....................             output_low(RED_LED); 
060A:  BCF    F93.5
060C:  BCF    F8A.5
....................             output_low(GREEN_LED); 
060E:  BCF    F92.5
0610:  BCF    F89.5
....................              
....................             fputc(PUL,TERM); 
0612:  MOVLW  06
0614:  RCALL  011C
....................             fputc(ADC_3,TERM); 
0616:  MOVF   20,W
0618:  RCALL  011C
....................              
....................             fputc(PUL,XBEE); 
061A:  MOVLW  06
061C:  MOVWF  25
061E:  RCALL  0124
....................             fputc(ADC_3,XBEE); 
0620:  MOVFF  20,25
0624:  RCALL  0124
....................         } 
....................          
....................         if (input(BUTTON1) != 1 && input(BUTTON2) != 1 && arpOn == 1) { // turn apreggiator off 
0626:  BSF    F95.2
0628:  BTFSC  F83.2
062A:  BRA    0642
062C:  BSF    F95.4
062E:  BTFSC  F83.4
0630:  BRA    0642
0632:  DECFSZ 24,W
0634:  BRA    0642
....................             arpOn = 0; 
0636:  CLRF   24
....................             fputc(0x09,TERM); 
0638:  MOVLW  09
063A:  RCALL  011C
....................                  
....................             fputc(0x09,XBEE); 
063C:  MOVLW  09
063E:  MOVWF  25
0640:  RCALL  0124
....................         } 
....................          
....................         buffer = 0; 
0642:  CLRF   23
0644:  CLRF   22
....................         output_high(GREEN_LED); 
0646:  BCF    F92.5
0648:  BSF    F89.5
....................         output_high(RED_LED); 
064A:  BCF    F93.5
064C:  BSF    F8A.5
....................         output_high(YELLOW_LED); 
064E:  BCF    F93.4
0650:  BSF    F8A.4
....................         delay_ms(10); 
0652:  MOVLW  0A
0654:  MOVWF  25
0656:  BRA    0164
....................     } 
0658:  BRA    01DC
.................... } 
065A:  BRA    065A

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN RESERVED
   Word  2: 1E19   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768
   Word  3: 8300   PBADEN CCP2C1 NOLPT1OSC MCLR RESERVED
   Word  4: 0000   NOSTVREN DEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
